% vim: ts=4 sts=4 sw=4 et tw=80
\chapter{助推器}
\label{chap:production_boosters}

\marginpar{73}
在这一章将会看到, 即使是一些小小的改动, 也可以极大地促进 Vim 的工作效率.
有些技巧是由 Vim 的特性提供的, 另外一些则需要用户自已编写一些脚本.

无论你把 Vim 当成一个修改配置文件的小工具, 还是把它用作某个大型开发项目的主要
编辑器, 你都可以发现本章介绍的方法可以极大地提高 Vim 的使用效率.

这一章讨论的主题包括:
\begin{itemize}
    \item 使用模版文件的模版
    \item 使用缩写的模版
    \item 使用已知单词与 Tag List 的自动补全
    \item 使用 Omnicompletion 的自动补全
    \item 宏与宏录制
    \item 使用会话
    \item 使用会话的项目管理
    \item 寄存器与撤消分支
    \item 折叠
    \item 使用 \texttt{vimdiff} 分析差异
    \item 使用 \texttt{netrw} 随时随地地打开文件
\end{itemize}

阅读完这一章之后, 用户使用 Vim 的工作效率应该可以提高好几个百分点.
\marginpar{74}

\section{模版}
\label{sec:using_templates}

无论编辑的是哪一种类型的文件, 当打开一个新文件时, 总有一些基础性的工作需要完成.
手动完成这些基础工作是一件非常乏味的事件, 更讨厌的是每次打开一个新文件时, 都
要重新再做一遍. 所以说干嘛要花这么多的时间, 来做一件使用模版就可以完成的事情?

在接下来的两节, 将会看到一些不同类型的模版. 其中一些模版特定于文件类型, 另
外一些则会使用用户的输入来触发小内容模版 (比如, 程序员经常用到的代码片断).

\subsection{模版文件}
\label{subsec:using_template_files}

每次打开一个新文件时, 用户做的第一件事经常是输入某些头部信息, 当然, 所要输入的
信息取决于文件的类型. 比较常见的例子包括:
\begin{itemize}
    \item 在新的 HTML 文件中添加基本结构 (\texttt{<html>}, \texttt{<head>},
        \texttt{<body>}).
    \item 在所有的 C 文件添加头部信息, 在文件 \texttt{main.c} 中添加
        \texttt{main()} 函数.
    \item 在 Java 文件中添加主类.
\end{itemize}
除了这些, 读者应该还能想到其他一些例子.

那么, 怎么才能创建一个模版文件? 不妨用 HTML 文件作为例子来进行讲解.
这种文件的结构是静态的, 因此非常适合用模版来处理. HTML 模版的内容是:
\begin{vimcode}
<html>
    <head>
        <title></title>
            <meta name="generator" content="Vim" />
            <meta name="author" content="Kim Schulz" />
    </head>
    <body>
        <p>Content goes here...</p>
    </body>
</html>
\end{vimcode}
在 \texttt{VIMHOME} 目录下创建一个新目录 \texttt{templates/}, 并把上面的
模版文件保存到这个目录中, 假设把模版文件命令为 \texttt{html.tpl}.
\marginpar{75}
现在, 第一个模版已经准备就绪, 不过, 创建一个新的 HTML 文件时, 需要加载
模版文件, 为了完成加载, 把下面这行命令添加到 \texttt{vimrc} 中:
\begin{vimcode}
:autocmd BufNewFile *.html 0r $VIMHOME/templates/html.tpl
\end{vimcode}
这个命令可以确保在新建一个 \texttt{*.html} 文件时, 模版文件的内容会自动加
载到新文件中. 于是, 在开始编辑新文件前, 文件中就已经包含了模版的内容.

本来这样做没什么问题, 但是当添加的模版文件越来越多时, 用户可能会越来越讨厌每
次都要往 \texttt{vimrc} 中添加一行加载命令. 所以, 把加载模版的命令写得
更灵活一点:
\begin{vimcode}
:autocmd BufNewFile * silent! 0r $VIMHOME/templates/%:e.tpl
\end{vimcode}
命令的功能是: 无论何时打开一个新文件, Vim 就在模版目录中搜索以文件扩展名命名
的模版. 比如, 创建一个 \texttt{index.html} 文件时, Vim 就在
\texttt{\$VIMHOME/templates/} 中搜索名为 \texttt{html.tpl} 的模版文件.

如果没有找到指定的模版, Vim 就创建一个空文件.

再把模版写得更完善一点: 添加对占位符 (占位符指的是将要添加文本的地方) 的
支持. 一个占位符看起来可以非常得与众不同, 这取决于用户, 我通常把它们显示成类似
于 \texttt{<+KERWORD+>} 的形式. 如果在前面的 HTML 模版中添加上占位符,
模版的内容就变成了:
\begin{vimcode}
<html>
    <head>
        <title><+TITLE+></title>
            <meta name="generator" content="<+GENERATOR+>" />
            <meta name="author" content="<+AUTHOR+>" />
    </head>
    <body>
        <p><+CONTENT+></p>
    </body>
</html>
\end{vimcode}

现在, 已经准备好了占位符, 接下来的工作就是在占位符之间跳转. 为了让跳转更加
方便, 把跳转命令添加到 \texttt{vimrc} 中. 用户可能想要把组合键 \key{Ctrl+j}
映射到跳转命令, 因为这样做的话便于在插入模式下使用, 组合键中 \texttt{j} (意
指 jump) 也更容易记忆. 映射组合键的命令是:
\begin{vimcode}
nnoremap <c-j> /<+.\{-1,}+><cr>c/+>/e<cr>
inoremap <c-j> <ESC>/<+.\{-1,}+><cr>c/+>/e<cr>
\end{vimcode}
\marginpar{76}
现在, 只需要按下组合键 \key{Ctrl+j}, 你就可以方便地跳转到文件中的下一个占位符,
输入文本, 然后再跳转到下一个占位符.

通过在占位符中添加关键字, 就可以提醒用户应该在占位符中输入什么样的内容.

\begin{warning}
可以通过命令 \texttt{match} 高亮显示占位符, 具体的设置命令是:
\verb'match Todo /<+.\++>/', 把这行命令添加到 \texttt{vimrc} 中 (可以把命令中的
\texttt{Todo} 替换成任意一种你喜欢的色彩组.
\end{warning}

\subsection{把缩写作为模版}
\label{subsec:abbreviations_as_templates}

上一小节介绍了如何为不同类型的文件制作模版, 这一节介绍如何为文件内容制作模版.

第 \ref{chap:personalizing_vim} 章简单地介绍了如何通过缩写来减少击键的
次数, 现在把缩写应用到模版中. 回忆一下下面这个命令的作用:
\begin{vimcode}
:iabbrev match replace-string
\end{vimcode}
我们只想让上面的命令工作在插入模式, 这是因为模式模版本来就应该工作在插入模式下.
对于 C 文件来说, 一个常见的例子是:
\begin{vimcode}
:iabbrev <buffer> for( for (x=0;x<var;x++){<cr><cr>}
\end{vimcode}
无论在什么时候输入文本 \texttt{for(}, Vim 都会自动插入一段 \texttt{for} 循
环. \texttt{(} 可以防止手工输入的 \texttt{for} 循环被自动转换. 插入的内容看起
来就像:
\begin{vimcode}
for (x=0;x<var;x++){

}
\end{vimcode}

\begin{warning}
    缩写词左边的 \texttt{<buffer>} 把命令的作用范围限制在当前缓冲区内.
\end{warning}

正如你所看到的那样, 生成的代码模版是静态的. 为了让模版更灵活一点, 把前面一节介
绍的占位符应用进来.
\marginpar{77}
在这种情景下使用的占位符更像是一个跳转点, 因此把它们简化成 \texttt{<+++>}.
除此之外, 在插入模式模版之后, 需要在光标的下一个位置上放置一个占位符, 对于
前面的例子来说, 光标的下一个位置应该是左括号的右边.

为了实现这个目标, 引入 \texttt{!cursor!} 占位符, 命令的内容是:
\begin{vimcode}
iabbrev for( for(!cursor!;<+++>;<+++>){<cr><+++><cr>}<Esc>
    :call search('!cursor!','b')<cr>cf!:
\end{vimcode}
(上面的命令都在同一行上)

现在, 无论何时输入 \texttt{for(}, Vim 都会自动插入一段 \texttt{for} 循环, 然后
把光标移动到占位符 \texttt{!cursor!} (当光标移过来时, 占位符上原来的内容会自动
被移除). 接下来, 用户就可以方便地填写 \texttt{for} 循环的参数, 并用 \key{Ctrl+j}
跳转到下一个参数的位置.

也许读者已经知道, 许多编程语言都有相同的主要结构 (比如 \texttt{for} 循环), 但是
它们之间的差异导致了无法使用同一个模式模版. 再回过头来看一下手上已有的东西,
看看是否可以让它们识别文件类型.

前面的一节介绍了如何根据文件的扩展名来加载相应的模版文件, 具体的命令
是:
\begin{vimcode}
:autocmd BufNewFile * silent! 0r $VIMHOME/templates/%:e.tpl
\end{vimcode}
对这个命令进行修改, 使得 Vim 可以根据文件的类型, 为模式模版自动加
载适当的缩写.

为了能让命令更聪明一点, 把命令的功能用函数来实现. 函数的代码是:
\begin{vimcode}
function! LoadTemplate(extension)
    silent! :execute '0r $VIMHOME/templates/'. a:extension. '.tpl'
    silent! execute 'source $VIMHOME/templates/'.a:extension.'.patterns.tpl'
endfunction
\end{vimcode}
为了调用函数, 把 \texttt{autocmd} 修改成:
\begin{vimcode}
:autocmd BufNewFile * silent! call LoadTemplate('%:e')
\end{vimcode}
函数 \texttt{LoadTemplate} 在 \texttt{\$VIMHOME} 的 \texttt{templates} 子目录
下搜索两个文件: \textit{extension}\texttt{.tpl} 与 \textit{extension}
\path{.patterns.tpl},
其中 \textit{extension} 表示当前打开着的文件的扩展名.
\marginpar{78}
第 1 个文件包含了特定文件类型的模版, 而第 2 个文件则包含了特定文件类型的缩写
命令. 如果没有找到对应的文件, 那么命令 \texttt{silent!} 就会抑制错误信息的输
出, 什么也不会显示出来.

现在, 模版文件中该包含什么样的内容完全由用户来决定.

\begin{warning}
    已经有人为 Vim 编写了大量的模版系统脚本, 其中大部分都是以本章介绍的概念为基础,
    但是增加了许多额外的功能. 除了这里介绍的之外, 如何用户还想要更多的模版选项,
    笔者推荐你看一下由 Gergely Kontra 编写的 mu-template, 可以到下面这
    个网址下载: \url{http://www.vim.org/scripts/script.php?script_id=222}.
\end{warning}

\subsection{snipMate 脚本}
\label{subsec:snippets_with_the_snipmate_script}

虽然已经有大量的模版系统脚本可供使用, 而且它们中的大部分都是以本章介绍的概念
为基础, 但是有时候对于特定的文件格式, Vim 还是没有提供足够的支持. 对于这些情况,
用户可以使用代码片断脚本.代码片断和用在模版中的缩写有点类似, 但是要更高级一
点.

如果读者想在 Vim 中使用代码片断, 笔者推荐 snipMate 脚本, 下载地址是
\url{http://www.vim.org/scripts/script.php?script_id=2540}.

snipMate 可以让用户在不需要了解 Vim 脚本的前提下, 为自己的文件格式定义高级的
代码片断.

假设用户想为 \texttt{for} 循环创建一个代码片断 (在前面的一节里用的是
\texttt{iabbrev}),  那就这样做:
\begin{vimcode}
snippet for
    for (${1:i} = 0; $1 < ${2:count}; $1${3:++}) {
        ${4:/* code */}
    }
\end{vimcode}
把上面这段文本写到一个文件中, 再把这个文件放到 \texttt{\$VIMHOME/snippets} 目
录下, 把文件命名为 \textit{filetype}\texttt{.snippet} (\textit{filetype}
表示文件类型,
比如 C 代码就写成 \texttt{c.snippet}, PHP 代码就写成 \texttt{php.snippet}).
\marginpar{79}
脚本的第一行表示开始一个新的代码片断, 当输入 \texttt{for} 并且后面再紧跟着一个
\key{Tab} 键时, 执行代码片断脚本.

再接下来的一行是最神奇的, 脚本实际生成的代码就像:
\begin{vimcode}
    for (i = 0; i < count; i++) {
        /* code */
    }
\end{vimcode}

代码片断被插入之后, 它把光标放在了第 1 个 \texttt{i} 的位置, 并切换到插入
模式, 可以轻易地把 \texttt{i} 换成另一个变量. 现在, 最神奇的事情发生了,
第 1 个 \texttt{i} 被换掉之后, 第 2 个 \texttt{i} (后面带有 \texttt{++}
的那个) 也会自动更新成新变量. 修改了 \texttt{i} 之后 (如果需要的话), 按下
\key{Tab} 键, 光标就会跳转到 \texttt{count}, 并再次切换到插入模式. 现在你可以
以同样的步骤修改 \texttt{count} 并按下 \key{Tab} 键, 之后, 光标跳转到
\texttt{++}, 再按下 \key{Tab} 跳到 \texttt{/* code */}, 你可以在这里写下其他代
码.

在代码片断的不同变量之间跳转, 简直不能再简单了.

snipMate 系统通过查找由 \texttt{\$\{NUMBER:INITIAL\_VALUE\}} 创建的特殊标记进行
工作. 标记中的 \texttt{NUMBER} 指出了按下 \key{Tab} 时, 将要跳转到的序列.
如果 \texttt{NUMBER} 是 1, 那么光标会首先处在这个位置上, 如果 \texttt{NUMBER}
是 3, 那么它就是按下两次 \key{Tab} 后光标所在的位置, 以此类推.
\texttt{INITIAL\_VALUE} 是在修改代码片断之前, 首先插入到代码中的文本.
比如 \texttt{\$\{1:i\}} 把 \texttt{i} 作为文本插入到代码中, 并首先把光标
放在此处.

如果需要在多个地方使用同一个变量, 可以通过 \texttt{\$NUMBER} 来引用. 比如说,
想要让 \texttt{i} 出现在多个地方, 那就在需要出现 \texttt{i} 的地方写上
\texttt{\$1} 即可. 写上 \texttt{\$1} 所有地方在开始时都会显示成 \texttt{i},
当改变 \texttt{i} 时, 其他地方的 \texttt{i} 也会自动更新.

这里介绍的只是创建代码片断的基础知识, 不过一旦在系统中安装了 snipMate,
就可以通过 Vim 的帮助系统学习到更多的高级知识.

还可以在 snipMate 中找到更多的惊喜. 用户会发现, snipMate 已经为许多常见
的文件格式准备好了代码片断脚本, 包括 \texttt{.c}, \texttt{.php},
\texttt{.perl}, \texttt{.java}, \texttt{.html}, \texttt{.tex}, 甚至还包括 Vim
脚本.
\marginpar{80}

\begin{warning}
    关于下载与如何使用 snipMate 脚本, 用户可以访问
    \url{http://www.vim.org/scripts/script.php?script_id=2540}.
\end{warning}

\section{Tag List}
\label{sec:using_tag_list}

Tag List 就像是程序员的字典. Tag List 实际上是一个包含了所有种类的关键词的文件,
这些关键词可以用来识别程序的各个要素, 包括函数名, 变量名, 类的方法, 具体的要素
依赖于编程语言. Tag List 文件并非由 Vim 生成, 而是 Tag List 生成程序. Tag List
生成程序有很多种, 比较常见的有:
\begin{itemize}
    \item Exuberant Ctags: 用于 C, C++, Java, Perl, Python, Vim, Ruby (以及其
        他 25 种语言)
    \item Vtags: 用于 Verilog 文件
    \item Jtags: 用于 Java 文件
    \item Hdrtags: 用于 C/C++, Asm, Lex/Yacc, LaTeX, Vim, Maple
    \item Ptags: 用于 Perl 文件
\end{itemize}

因为 Exuberant Ctags (简称 Ctags) 使用得最为广泛, 支持的语言也是最多的, 因此
在下面的例子里我们用它生成 Tag List.

以一个小项目进行讲解, 这个项目包含了 3 个 C 文件:
\begin{itemize}
    \item \texttt{main.c}: 包含 \texttt{main} 函数的文件
    \item \texttt{myfunctions.c}: 包含了程序中用到的各个函数
    \item \texttt{myfunctions.h}: \texttt{myfunctions.c} 中的函数的头文件
\end{itemize}
假设代码已经写完, 现在为这些代码文件生成一个 Tag List 文件.

在存放源代码文件的目录下执行命令:
\begin{vimcode}
ctags *.c *.h
\end{vimcode}
命令执行完毕后, 会在当前目录下创建一个新文件, 文件名是 \texttt{tags}.
这个文件就是 Tag List 文件, 它包含了源代码中所有函数与变量的信息.
\marginpar{81}
\begin{warning}
    \texttt{ctags} 命令提供了大量的参数, 用于指定编程语言, 更多的信息可以通过
    \texttt{ctags --help} 来查看.
\end{warning}
启动 Vim 后, 必须告诉它去使用 \texttt{tags} 文件, 这可以通过设置选项
\texttt{tags} 来完成:
\begin{vimcode}
:set tags=/path/to/tags
\end{vimcode}
现在, Vim 已经知道了 \texttt{tags} 文件的存在, 接下来就可以在 Vim 使用它.

\texttt{main.c} 调用了 \texttt{myfunctions.c} 中定义的函数. 假设用户
知道有一个函数叫作 \texttt{calcValue}, 但却不知道该函数接收什么样的参数, 比较
好的做法是看一下函数是如何定义的, 这时候就可以使用 \texttt{tags} 文件提供的功
能. 假设用户已经在源代码文件中写下了:
\begin{vimcode}
myvalue = calcValue(
\end{vimcode}
为了查看函数 \texttt{calcValue} 的定义, 把光标移动到函数名上, 按下组合键
\key{Ctrl+]}, 此时会出现下面两种情况中的一种:
\begin{itemize}
    \item 只找到一个匹配, 于是光标会直接跳转到定义函数的地方
    \item 找到多个匹配, 于是 Vim 把这些匹配以列表的形式显示出来
\end{itemize}
在第 2 种情况下, 用户可以选择跳转到哪一个匹配. 如果用户使用的编程语言支持重载,
就会出现这种情况: 同一个函数有多个版本.

函数看完之后, 用户需要回到之前离开的地方, 继续往下工作. 按下组合键
\key{Ctrl+t} 就可以跳转到上一次离开的地方.

\begin{warning}
    如果用的是 Gvim, 还可以通过鼠标来跳转到关键词的定义: 按住 \key{Ctrl} 键
    的同时, 按下鼠标左键.
\end{warning}
用户可以把在 tag 间的跳转当成栈操作. 当跳转到一个关键词时, 相当于把关键词的 tag
压栈, 从 tag 返回时, 相当于把栈顶的 tag 弹出栈.
\marginpar{82}
使用下面这个命令查看当前的栈状态:
\begin{vimcode}
:tags
\end{vimcode}
\begin{center}
    \includegraphics[scale=0.5]{./images/page82.png}
\end{center}
上图中以 \texttt{>} 开始的行是当前所在的 tag. 除了组合键 \key{Ctrl+]}
与 \key{Ctrl+t}, 还可以用下面这两个命令完成同样的功能:
\begin{itemize}
    \item \texttt{:tag}: 跳转到这个 tag
    \item \texttt{:pop}: 回到上一个 tag
\end{itemize}

如果匹配的 tag 比较多, 要是能把这些 tag 以列表的形式罗列出来可能会比较方便.
为了得到这个列表, 可以用下面两个命令中的任意一个:
\begin{itemize}
    \item \texttt{:tselect}
    \item \texttt{:ptselect}
\end{itemize}
第 1 个命令列出所有匹配的 tag, 为了选择其中一个, 需要输入 tag 所在行的行首的
数字.

第 2 个命令完成同样的工作, 但是它会在预览窗口中显示列表. 如果用户选错了 tag,
或者是想查看列表中的下一个 tag, 可以用下面的命令在 tag 间移动:
\begin{itemize}
    \item \texttt{:tnext}: 移动到列表中的下一个 tag
    \item \texttt{:tprev}: 移动到列表中的前一个 tag
\end{itemize}

用户可能还没有从前面的例子中体会到 Tag List 的强大之外, 想像一下, 假设项目中的
文件不只 3 个, 而是散布在数百个目录中的上千个文件, 这时候, 用户肯定没办法记住
每个函数所在的位置, 这时候就非常需要一个强大的索引工具, 就像 Tag List.
\marginpar{83}
\subsection{更便捷的 Tag List 导航}
\label{subsec:easier_taglist_navigation}

在大多数的非英文键盘布局中, 按键 \texttt{]} 无法直接使用, 必须通过其他的组合
键 --- 比如 \key{Ctrl+Alt+G+r+9} --- 完成 \key{Ctrl+]} 的功能. 在这种情况下,
把命令映射到直接可用的按键上会更方便一点, 对此, 笔者使用了下面的映射:
\begin{vimcode}
:nmap <buffer> <F7> <C-]>
:nmap <buffer> <C-F7> <C-T>
:nmap <buffer> <A-F7> :ptselect<cr>
:nmap <buffer> <F8> :tnext<cr>
:nmap <buffer> <C-F8> :tprev<cr>
\end{vimcode}
现在, 用户可以用 \key{F7} 与 \key{Ctrl+F7} 在 tag 间跳转, 用 \key{Alt+F7}
获取 tag 列表, 用 \key{F8} 与 \key{Ctrl+F8} 遍历 tag.

\subsection{Tag List 的其他用法}
\label{subsec:other_usages_of_taglists}

Taglist 不仅可以用来查找函数与变量的定义, 还可以用来查找其他信息. 笔者在这里只
是简单地提一下 Tag List 在 Vim 中的其他应用:
\begin{itemize}
    \item \texttt{lookupfile.vim}: 由 Hari Krishna Dara 开发, 该脚本使用 tag
        list 在一个预处理过的项目中查找指定的文件, 脚本的最新版见
        \url{http://www.vim.org/scripts/script.php?script_id=1581}.
    \item \texttt{taglist.vim}: 由 Yegappan Lakshmanan 开发的插件, 在程序员中
        非常流行. 它是一个完整的源代码浏览工具, 在一个分割的窗口中显示函数,
        关键词, 变量, 定义的概览. 插件的下载地址是
        \url{http://www.vim.org/scripts/script.php?script_id=273}.
    \item \texttt{ctags.vim}: 由 Gary Johnson 与 Alexey Marinichev 开发.
        脚本可以在状态条或窗口标题栏中显示光标所在位置的函数的名字. 脚本使用
        Exuberant Ctags 为当前打开的文件自动生成 tag 文件. 脚本的下载地址是
        \url{http://www.vim.org/scripts/script.php?script_id=610}.
    \item \texttt{autoproto.vim}: Jochen Baier 专门为 C 程序员开发的脚本. 当
        程序员输入函数名与第一个左括号后, 脚本在预览窗口中显示该函数的原型.
        脚本的下载地址是
        \url{http://www.vim.org/scripts/script.php?script_id=1553}.
\end{itemize}
\marginpar{84}
\begin{warning}
    关于 tag 的更多信息与使用方法, 可以查阅 Vim 的帮助系统 \texttt{:help tags}.
\end{warning}

\section{自动补全}
\label{sec:using_autocompletion}

作为一个遵循 Vim 哲学的用户, 总是希望用最少的击键来完成一件事, 因为额外的击键
意味着额外的时间.

所以说, 如果 Vim 可以猜出用户正想打的单词, 并且可以自动补全, 那又何必每次
都从头输到尾呢?

在 Vim 中有多种办法来自动补全单词, 其中一些只能补全用户曾经在某个打开的缓冲区
中输过的单词, 还有一些牵涉到了对当前正在使用的代码的分析 --- 不仅仅是当前打开
文件, 还包括整个源代码树.

接下来的小节讨论使用自动补全的三种方法:
\begin{itemize}
    \item 已知单词的自动补全
    \item 基于字典文件的补全
    \item 识别上下文的自动补全
\end{itemize}
除此之外, 还会介绍一些使用技巧, 通过按键绑定来更方便地使用自动补全.

\subsection{已知单词的自动补全}
\label{subsec:autocompletion_with_known_words}

这一节将会看到自动补全的最简单的用法 --- 为已知单词进行补全.

无论用户在写什么内容, 都会出现输入重复单词的情况. 在 Vim 中, 用户可以在输入
完单词的头两个字母后, 按下组合键 \key{Ctrl+n}.
\marginpar{85}

假设用户想要在 Vim 中输入 ``I have beautiful flowers in my flower garden''.

在刚开始时, 文件中没有任何其他的内容, 因此用户不得不一个字母一个字母地写下
文本的开始部分, 直到 ``I have beautiful flowers in my f''.

用户接下来会输入单词 ``flower'', 但是, 由于在前面已经输入了 ``flowers'',
当输入 ``f'' 后, 按下 \key{Ctrl+n}, Vim 就会把 ``f'' 自动扩展为 ``flowers'',
只要把多余的 ``s'' 删掉即可. 和输入整个单词相比, 这要快很多.

随着文本的增多, 读者会发现越来越多的单词可以自动补全.

组合键 \key{Ctrl+n} 所做的工作是向前搜索匹配的单词. 如果用户知道自己刚刚才输入
过同样的单词, 那么用 \key{Ctrl+p} 会更快一点, 因为这个组合键是向后搜索匹配.
一般来说, 除非文件非常大, 或者可能的匹配非常多, 否则 \key{Ctrl+n} 与
\key{Ctrl+p} 对用户来说并没有太大的区别.

\subsection{使用字典的自动补全}
\label{subsec:autocompletion_using_dictionary_lookup}

一个比较好的使用技巧是把用户所使用的语言的全部单词, 都搜集到一个巨大的字典
文件中, 然后再把这个文件作为字典加载到 Vim 中 (在因特网上很容易搜索到这种文件).
为了把文件作为字典载入到 Vim 中, 执行下面的命令:
\begin{vimcode}
:set dictionary+=/path/to/dictionary/file/with/words
\end{vimcode}
现在, Vim 已经事先知晓了大量的单词, 用户可以利用这些单词进行自动补全. 不过,
有一些地方会不一样. 因为补全时被搜索的单词并非在某个打开的缓冲区中, 而是
在选项 \texttt{dictionary} 所配置的字典文件中, 所以需要用另一个快捷键:
\key{Ctrl+x+k}.
\marginpar{86}
按下 \key{Ctrl+x} 后, 会进入补全模式, 再接着按下 \key{Ctrl+k}, 就可以在字典中
查询关键词 (\key{k} 指是的是 keyword).
\begin{center}
    \includegraphics[scale=0.6]{./images/page86.png}
\end{center}

还有其他几种补全类型, 包括:

\key{Ctrl+x} 后跟:
\begin{itemize}
    \item \key{Ctrl+l}: 补全一整行文本
    \item \key{Ctrl+n}: 从当前缓冲区中补全单词
    \item \key{Ctrl+k}: 从字典中补全单词
    \item \key{Ctrl+t}: 从同义词典中补全单词 (见 \texttt{:help 'thesaurus'})
    \item \key{Ctrl+i}: 从当前文件与被包含的文件中补全单词
    \item \key{S}: 拼写建议 (仅 Vim 7.0 以上的版本支持)
\end{itemize}

其他的将会在下节介绍.

\subsection{Omnicompletion}
\label{subsec:omnicompletion}

哪些内容应该自动补全, 哪些内容不应该自动补全 --- 对此我们都有完美的解决办法.
但是对于 Vim 来说, 在 7.0 版出现之前, 用户对补全并没有绝对的控制权.

Vim 7.0 引入了一种全新的补全技术 --- Omnicompletion. 它使得用户可以精确地定义
补全功能应该如何工作. 实际上, 用户需要自己来编写补全函数 (除非已经有人把函数
写好了).
\marginpar{87}
和前一节介绍的一样, 激活补全的方法是先输入几个字母, 按下 \key{Ctrl+x} 进入到
补全模式, 再紧接着按下 \key{Ctrl+o} 使用 Omnicompletion.

为了添加用户自定义的补全函数, 执行:
\begin{vimcode}
:set omnifunc=MyCompleteFunction
\end{vimcode}
现在, 用户只需要定义函数 \texttt{MyCompleteFunction}, 这个函数用于完成补全操作.
上面的命令只在当前活动缓冲区内才有效, 如果希望每个缓冲区都可以使用该补全函数,
那么就要对每个缓冲区执行这个设置命令.
\begin{warning}
    \texttt{omnifunc} 的设置通常在文件类型插件内完成, 这样的话, 补全函数就可以绑
    定到特定的文件类型上.
\end{warning}

现在来看一个补全函数的例子. 假设用户有一个通讯录文件, 文件的内容是人名及其邮件
地址, 就像:
\begin{vimcode}
Kim Schulz|kim@schulz.dk
John Doe|john.doe@somedomain.com
Jane Dame|jd@somedomain2.com
Johannes Burg|jobu@somedomain3.net
Kimberly B. Schwartz|kbs@somedomain.com
\end{vimcode}

用户想在写完一个人名后, 通过补全插入对应的邮件地址, 完成这个功能的函数是:
\begin{vimcode}
function! CompleteEmails(findstart, base)
	  if a:findstart
	    " locate the start of the word
	    let line = getline('.')
	    let start = col('.') - 1
	    while start > 0 && line[start - 1] =~ '\a'
	      let start -= 1
	    endwhile
	    return start
	  else
	    " find contact names matching with "a:base"
	    let res = []
		 " we read contactlist file and sort the result
	    for m in sort(readfile('/home/kim/.vim/contacts.txt'))
	      if m =~ '^' . a:base
				let contactinfo = split(m, '|')
\end{vimcode}
\marginpar{88}
\begin{vimcode}
		      " show names in list, but insert email address
		      call add(res, {'word': contactinfo[1],
                     \ 'abbr': contactinfo[0].' <'.contactinfo[1].'>',
                 \ 'icase': 1} )
	      endif
	    endfor
	    return res
	  endif
	endfunction
\end{vimcode}

函数接收两个参数 --- 所有的 Omnicompletion 函数都是如此. Vim 第一次调用函数时,
把第 1 个参数 \texttt{findstart} 设置为 1 (\texttt{base} 为空). 这样的参数状态
表示这是第一次调用, 函数应该搜索用户当前所写的单词的开始.

然后, Vim 再次调用函数, 这次调用把 \texttt{findstart} 设置为 0, 把 \texttt{base}
设置成开始补全的单词. 这一次, 函数会打开通讯录文件, 以行为单位, 把文件读到
一个列表中, 对列表排序, 然后遍历列表.

每一行的内容按照 \texttt{|} 分割, 如果某个单词, 是以用于补全的单词的字母作为开
始, 那就把这个单词添加到结果列表中, 这个结果列表最后会作为函数的返回值返回.
函数可以修改弹出内容的外观, 和它所匹配的内容, 这两个功能无法通过添加电子邮件
地址来完成, 而是要通过构建一个字典 (见 \texttt{:help Dictionary}), 在构建字典
时会接触到一些特定的关键词. 在这个案例中使用下列三个关键词:
\begin{itemize}
    \item \texttt{word}: 应该插入的真正的单词
    \item \texttt{abbr}: 在弹出列表中使用的单词, 而非直接使用 \texttt{word}
    \item \texttt{icase}: 如果其值非零, 则匹配是区分大小写的
\end{itemize}

其他的关键词及其意义可以在 Vim 的帮助系统中找到:
\begin{vimcode}
:help 'omnifunc'
\end{vimcode}

现在 Vim 已经有了一个单词列表用于补全, 在这个案例中则是一些像下面这样的行:
\begin{vimcode}
"Kim Schulz <kim@schulz.dk>"
\end{vimcode}
无论何时写下一些字母,比如 \texttt{ki}, 然后按下 \key{Ctrl+x Ctrl+o}, Vim 就会
以列表的形式, 弹出所有的, 以 \texttt{ki} 开始的名字.
\marginpar{89}
\begin{center}
    \includegraphics[scale=0.55]{./images/page89.png}
\end{center}
按 \key{Ctrl+o} 可以循环遍历列表中的条目. 另外, 还可以用 \key{Ctrl+n} 向前遍历,
用 \key{Ctrl+p} 向后遍历.

\subsection{多合一补全}
\label{subsec:all_in_one_completion}

用户可能不想记住这么多的补全快捷键, 为什么就不能为所有的补全类型只使用一个快捷
键呢? Vim 可以帮助你实现这个愿望, 现在来看一下具体要怎么做.

大部分支持补全的编辑器通常把这个功能映射到 \key{Tab} 键.

通过下面这个命令, 用户可以在 Vim 的帮助系统中找到一个叫作
\texttt{CleverTab()} 的函数:
\begin{vimcode}
:help ins-completion
\end{vimcode}
这个函数可以让用户使用 \key{Tab} 键来补全单词, 而非 \key{Ctrl+n}. 函数可以自动
区分是应该插入一个制表符, 还是应该做补全操作. 如果用户是在一行的开始, 或者是
某个空白符的后面按下 \key{Tab} 键, 那就是插入一个制表符. 在其他的情况下, 函数
会试图完成已知单词的补全.

借用帮助系统中的 \texttt{CleverTab} 函数, 并对它加以扩展, 使得它可以从下
面的, 带有优先级的列表中选择补全方法:
\begin{itemize}
    \item Omnicompletion
    \item 字典补全
    \item 已知单词的补全
\end{itemize}
\marginpar{90}
下面是实现该函数的一个例子:
\begin{vimcode}
function! SuperCleverTab()
	'check if at beginning of line or after a space
    if strpart( getline('.'), 0, col('.')-1 ) =~ '^\s*$'
      return "\<Tab>"
    else
		" do we have omni completion available
       if &omnifunc != ''
		" use omni-completion 1. priority
          return "\<C-X>\<C-O>"
       elseif &dictionary != ''
			" no omni completion, try dictionary completio
			return "\<C-K>"
		else
			"use omni completion or dictionary completion
			"use known-word completion
          return "\<C-N>"
      endif
    endif
endfunction

" bind function to the tab key
inoremap <Tab> <C-R>=SuperCleverTab()<cr>
\end{vimcode}

把函数的代码与按键绑定添加到 \texttt{vimrc} 中, 然后用户就可以用 \key{Tab} 键来
完成各种类型的补全.

按下 \key{Tab} 键进行补全时, 函数检查此时是否是要插入一个制表符. 如果不是, 那
就检查 Omnicompletion 函数 (通过 \texttt{omnifunc} 设置) 是否可用. 如果函数不
可用, 那就检查字典是否可用. 如果字典还是不可用, 那就使用最简单的已知单词补全.

\section{宏录制}
\label{sec:using_macro_recording}

编辑具有单一结构的文本时, 或许最好的功能就是录制一段输入宏, 然后再重复执行宏.

完成这个工作的接口非常简单, 更强大的是, 几乎任何东西都可以录制, 接下来我们就
来介绍这个强有力的工具.
\marginpar{91}

先看一下将会用到的命令:
\begin{itemize}
    \item \texttt{qa}: 从现在开始录制, 并记录到寄存器 \texttt{a}. 可以使用任意
        的寄存器, 用寄存器 \texttt{a} 只是为方便起见.
    \item \texttt{q}: 如果是在正在录制时按下, 则停止录制
    \item \texttt{@a}: 执行记录在寄存器 \texttt{a} 中的宏 (可以把 \texttt{a}
        替换成其他的寄存器)
    \item \texttt{@@}: 执行上一次所执行的宏命令
\end{itemize}
可以在 \texttt{@} 前加上任意的数字, 表示重复执行该命令多少次. 例如,
\texttt{15@a} 表示把寄存器 \texttt{a} 中所记录的命令重复执行 15 遍.

先看一个普通的录制会话过程:
\begin{vimcode}
qq
command1
command2
....
commandN
q
10@q
\end{vimcode}
读者可能会好奇这有什么用, 因为这只是在重复执行一串命令罢了. 这种问题最好通过
例子来说明.

想像一下用户有一大串的信息需要处理, Unix 系统的日志文件就属于这种类型. 日志文件
的内容类似于:
\begin{vimcode}
Mar 20 17:23:54 Inspiron kernel: [33604.866998] ath9k 0000:09:00.0: no hotplug settings from platform
Mar 20 17:23:54 Inspiron kernel: [33604.867007] pcieport 0000:00:1c.7: no hotplug settings from platform
Mar 20 17:23:54 Inspiron kernel: [33604.867015] ehci-pci 0000:00:1d.0: no hotplug settings from platform
Mar 20 17:23:54 Inspiron kernel: [33604.867020] ehci-pci 0000:00:1d.0: using default PCI settings
Mar 20 17:23:54 Inspiron kernel: [33604.867039] lpc_ich 0000:00:1f.0: no hotplug settings from platform
Mar 20 17:23:54 Inspiron kernel: [33604.867043] lpc_ich 0000:00:1f.0: using default PCI settings
Mar 20 17:23:54 Inspiron kernel: [33604.867063] ahci 0000:00:1f.2: no hotplug settings from platform
Mar 20 17:23:54 Inspiron kernel: [33604.867067] ahci 0000:00:1f.2: using default PCI settings
Mar 20 17:23:54 Inspiron kernel: [33604.867084] pci 0000:00:1f.3: no hotplug settings from platform
Mar 20 17:23:54 Inspiron kernel: [33604.867089] pci 0000:00:1f.3: using default PCI settings
...
\end{vimcode}
\marginpar{92}

现在, 用户想要把这个日志文件转换成 HTML, 并以表格的形式呈现数据, 看起来就像:
\begin{vimcode}
<tr><td>Oct 8 21:23:34</td><td>laptopia</td><td>kernel:</td><td>ACPI...</td><tr>
\end{vimcode}

用户可以选择一行一行地编辑文件, 直到最后一行. 但也可以这样做, 先编辑一行, 并把
编辑命令录制下来, 然后再把录制下来的命令应用到剩下的每一行. 最开始的编辑命令可
以是下面这些 (假设光标原来是在第一行的开始):
\begin{center}
    \begin{tabular}{ll}
    \hline
    \texttt{qa}             & 开始录制, 并把内容记录到寄存器 \texttt{a} 中 \\
    \texttt{i<tr><td>[ESC]} & 切换到插入模式, 插入 HTML 标记, 再回到普通模式 \\
    \texttt{/ [CR]}         & 向前搜索空格 \\
    \texttt{3n}             & 向前搜索到第 3 个空格 \\
    \texttt{xi</td><td>[ESC]}& 删除空格, 切换到插入模式, 添加 HTML 标记, 再切换
        到普通模式 \\
    \texttt{n}              & 前进到下一个空格 \\
    \texttt{xi</td><td>[ESC]}& 删除空格, 切换到插入模式, 添加 HTML 标记, 再切换
        到普通模式 \\
    \texttt{n}              & 前进到下一个空格 \\
    \texttt{xi</td><td>[ESC]}& 删除空格, 切换到插入模式, 添加 HTML 标记, 再切换
        到普通模式 \\
    \texttt{A</td></tr>[ESC]}&在行的末尾添加 HTML 标记, 再切换到普通模式 \\
    \texttt{j\^}            & 前进到下一行的开始 \\
    \texttt{q}              & 宏录制结束 \\
    \hline
\end{tabular}
\end{center}

\begin{warning}
    \texttt{[ESC]} 指的是按下转码键: \key{Esc}, \texttt{[CR]} 指的是按下回车键:
    \key{Enter}.
\end{warning}

宏准备好了, 光标的位置也已就位, 现在可以重复地执行宏, 并且在每次执行完宏后,
光标都会处在就绪的位置上.

用户可以用 \texttt{@a} 回放存放在寄存器 \texttt{a} 中的宏, 除此之外, 用户还
需要做的就是添加 HTML 的头部与尾部信息, 这很简单.
\marginpar{93}
这只是宏应用的一个简单示例, 如果读者认真回忆一下, 可能会想到更多的, 可以用宏
来优化的工作.

\section{会话}
\label{sec:using_sessions}

不知读者有没有想过, Vim 会为你保存多少信息. Vim 保存的信息涵盖了大量的内容, 其
中包括:
\begin{itemize}
    \item 打开的文件, 缓冲区, 窗口, 和标签页
    \item 历史命令
    \item 文本的变化点
    \item 选择与撤消分支
    \item 窗口, 分割 与 GUI 窗口的大小
    \item 光标的位置
\end{itemize}

保存的信息可以分为三类:
\begin{itemize}
    \item 第一类设置信息称为视图 (view), 该类信息应用到一个单独的窗口上. 一个视
        图可以被存储和还原, 因此每当用户使用视图时, 窗口都会呈现出相同的外观.
    \item 第二类设置信息称为会话 (session). 它是一系列视图的集合, 再加上视图
        之间如何配合的信息. 和视图一样, 会话也可以保存下来, 以便于稍后检索.
    \item 剩下的其他信息都归为第三类, 也就是所有的, 不能直接应用到任意一个窗口
        的全局设置. 这些设置可以用会话保存下来, 因此它们也可以保存/还原.
\end{itemize}

接下来的小节将会介绍如何在日常的工作中运用会话.

\subsection{简单的会话使用}
\label{subsec:simple_session_usage}

在使用会话的过程中, 最经常做的事就是把当前正在运行的会话 (如果没有经过特别的设
置, 则是默认会话) 保存到会话文件中, 这样就可以在需要时重新加载会话. 保存会话
的命令是:
\begin{vimcmdform}
\texttt{:mksession}\ \textit{file}
\end{vimcmdform}
保存当前视图的命令是:
\begin{vimcmdform}
\texttt{:mkview}\ \textit{file}
\end{vimcmdform}
\marginpar{94}
命令中的 \textit{file} 是用户指定的, 用于保存会话或视图的文件名. 如果没有指定该
参数, 则默认保存到当前工作目录的 \texttt{Session.vim} 文件中.

\begin{warning}
    如果文件事先存在, 为了覆盖掉文件原来的内容, 需要在 \texttt{mksession} 的末
    尾紧跟上一个感叹号 \texttt{!}.
\end{warning}

使用视图时, 用户可以同时拥有多个不同的视图. 如果每个视图都保存到当前工作目录下, 那
么用不了多长时间, 工作目录就会被视图文件填满. 为了避免这个问题, 可以用下面的命令
告诉 Vim, 应该把视图文件放到哪个目录下:
\begin{vimcode}
:set viewdir=$HOME/.vim/views
\end{vimcode}
上面的命令会把所有的视图文件保存到目录 \texttt{\$HOME/.vim/views}.

假设用户当前打开了三个窗口, 在退出 Vim 之前, 用户执行了:
\begin{vimcode}
:mksession
\end{vimcode}
在下一次准备打开文件时, 用户希望用相同的会话来启动 Vim, 此时可以用命令行选项
\texttt{-S}:
\begin{vimcode}
vim -S Session.vim
\end{vimcode}

除此之外, 用户也可以选择在启动 Vim 后, 用下面的命令来加载会话文件:
\begin{vimcode}
:source Session.vim
\end{vimcode}

对于视图, 加载方式是:
\begin{vimcode}
:loadview View.vim
\end{vimcode}

加载一个会话会改变编辑器的整体布局, 而加载一个视图则只会改变当前活动窗口的布局.
\marginpar{95}
\begin{warning}
    用户如果希望 Vim 记住所有的设置信息, 比如光标的位置与折叠信息, 那么就需要在
    \texttt{vimrc} 中添加如下内容:
    \begin{vimcode}
    set viewdir=$VIMHOME/views/
    autocmd BufWinLeave * mkview
    autocmd BufWinEnter * silent loadview
    \end{vimcode}
    无论何时在同一个窗口中打开另一个缓冲区, 之前的缓冲区的视图都会被自动保存下来,
    并且当再次打开之前的缓冲区时, 会自动还原保存的视图.
\end{warning}

会话的一个常用技巧是定义一个命令, 命令的功能是在退出 Vim 时自动保存会话, 而在打开 Vim
时自动还原保存的会话. 使用这个方法就可以让用户在不丢失设置, 已打开文件列表等
信息的前提下, 自由地启动与退出 Vim. 为了完成这个功能, 可以在 \texttt{vimrc} 中
添加如下命令:
\begin{vimcode}
autocmd VimEnter * call LoadSession()
autocmd VimLeave * call SaveSession()
function! SaveSession()
   execute 'mksession! $HOME/.vim/sessions/session.vim'
endfunction

function! LoadSession()
   if argc() == 0
      execute 'source $HOME/.vim/sessions/session.vim'
   endif
endfunction
\end{vimcode}
关闭 Vim 后, 会话保存到 \texttt{\$HOME/.vim/sessions/session.vim}.

根据打开 Vim 方式的不同, 或者是打开由命令行参数指定的文件, 或者是打开最后一次
会话. 比如说:
\begin{itemize}
    \item \texttt{vim file.txt}: 这种打开方式不会加载最后一次会话.
    \item \texttt{vim}: 这种打开方式会加载最后一次会话, 之前打开的文件会再次
        被打开.
\end{itemize}

如果用户希望在会话文件中存放更多的信息, 可以把额外的信息存放到额外的会话文件中.
方法是创建一个其名字类似于会话文件的文件, 不过要把扩展名 \texttt{.vim} 改成
\texttt{x.vim}. 例如, \texttt{Session.vim} 的额外会话文件是
\texttt{Sessionx.vim}. 额外的会话文件应该和其所属的会话文件放在同一目录下. 用户
可以把想要添加的命令全写到这个文件中, 当 Vim 加载会话文件时, 会把额外的会话
文件中的命令执行一遍.
\marginpar{96}

\subsection{满足个人的会话需求}
\label{subsec:satify_you_own_session_needs}

用户可能并不需要会话文件中存放的所有信息, 有时, 用户可能仅仅是想要保存打开过
的文件的信息, 而在其他时候, 可能是所有的会话信息. 幸运的是, Vim 提供了设置
保存会话信息的方法.

所使用的设置命令是 \texttt{sessionoptions}, 使用方法是:
\begin{vimcmdform}
\texttt{:set sessionoptions=}\textit{options}
\end{vimcmdform}
\textit{options} 是一个由逗号分隔的列表, 列表中可以出现下列选项:
\begin{center}
    \begin{tabular}{lp{35em}}
        \hline
        \textbf{\texttt{blank}}  & 保存空白窗口 \\
        \textbf{\texttt{buffers}} & 保存所有缓冲区的信息, 包括隐藏的与未加载的缓冲区 \\
        \textbf{\texttt{curdir}} & 保存当前工作目录的相关信息 \\
        \textbf{\texttt{folds}} & 保存缓冲区内容中的折叠信息 \\
        \texttt{globals} & 保存全局变量的相关信息, 这里的全局变量指的是以大写
        字母开始, 且类型为字符串或数值的变量 \\
        \textbf{\texttt{help}} & 保存帮助窗口 \\
        \texttt{localoptions} & 保存用户在单个窗口中创建的局部变量与局部映射的
        相关信息 \\
        \textbf{\texttt{options}} & 保存所有的选项信息, 包含全局的与局部的 \\
        \texttt{resize} & 保存 UI 窗口的尺寸信息 (行数与列数) \\
        \texttt{sesdir} & 如果设置了该选项, 当前目录就会是会话文件的存放目录
        (如果同时设置了 \texttt{curdir}, 则该选项不可用) \\
        \texttt{slash} & 把所有文件路径中的反斜杆换成斜杆 (这样做就可以让 Unix
        兼容 Windows 的文件路径) \\
        \textbf{\texttt{tabpages}} & 保存所有的标签页信息, 如果没有设置该选项, 则只会保
        存当前处于活跃状态的标签页 \\
        \texttt{unix} & 使用 Unix 格式的行结束符, 而非 Windows 格式 \\
        \texttt{winpos} & 保存 UI 窗口的屏幕位置信息 \\
        \textbf{\texttt{winsize}} & 保存所有打开窗口的尺寸 \\
        \hline
    \end{tabular}
\end{center}
\marginpar{97}
粗体显示的是 Vim 的默认设置选项. 每次设置选项时并不需要全部设置, 可以通过运算符
\texttt{+=} 和 \texttt{-=} 来增加或移除选项. 比如说, 用户想要在默认选项的基础上
添加 \texttt{winpos}, 并移除 \texttt{folds}, 可以这样做:
\begin{vimcode}
:set sessionoptions+=winpos
:set sessionoptions-=folds
\end{vimcode}
用下面的命令显示当前的会话选项:
\begin{vimcode}
:echo &sessionoptions
\end{vimcode}

\begin{warning}
    实际上, 用户可以用该方法查看所有的 Vim 设置: 通过执行命令 \texttt{:echo},
    并在选项名的前面加上 \texttt{\&}, 比如 \texttt{:echo \&somesessting}.
\end{warning}

\subsection{会话与项目管理}
\label{subsec:sessions_as_a_project_manager}

有时候, 用户可能想要把会话文件作为某种原始的项目文件来使用, 这些项目文件包含了
项目的相关信息. 因此, 如果用户正在处理某个项目, 并且打开了大量的文件与窗口, 只需
执行:
\begin{vimcode}
:mksession!
\end{vimcode}
该命令会把当前会话保存到当前工作目录的 \texttt{Session.vim} 文件中. 如果用户希望
在启动 Vim 时, 自动加载会话文件 (如果存在的话) , 可以把下面这行命令添加到
\texttt{vimrc}:
\begin{vimcode}
silent source! Session.vim
\end{vimcode}
添加了该命令之后, 如果在当前工作目录中存在 \texttt{Session.vim} 文件, 就可以自
动加载. 所以, 只要让会话文件保持在项目目录中, 用户就可以方便把项目加载到 Vim,
但是请记住, 如果打开了新文件, 或者是修改了窗口/缓冲区, 都需要重新保存会话文件.
\marginpar{98}

这只是把会话应用到项目管理的简单用法, 当然, 还有更高级的方法. Wenzhi Liang 开
发了一个实用的脚本, 在 Gvim 的菜单中添加了一个 Project 菜单项. 通过这个菜单项,
用户可以把当前会话保存为以项目命名的文件, 之后, 再通过点击菜单来还原项目, 还
可以在不同的项目之间切换. 如果用户不再需要某个项目, 还可以通过菜单来删除该项目
的会话文件.
\begin{center}
    \includegraphics[scale=0.6]{./images/page98.png}
\end{center}

关于该脚本的更多信息, 以及下载地址, 见:
\url{http://www.vim.org/scripts/script.php?script_id=279}

\begin{warning}
    该脚本要求系统中安装了 Perl 与 Bash.
\end{warning}

\section{寄存器与撤消分支}
\label{sec:registers_and_undo_branching}

用户可能都有过这种体验: 刚刚才删除完一段文本, 可是过了一会儿发现, 其他地方还需
要那段文本; 或者是已经复制/剪切了一段文本, 但是过了一会儿之后, 之前复制/剪切的文
本就不见了, 因为剪贴板只能存放一段文本, 后面的文本会把前面的文本给覆盖掉 ---
Vim 是不会让这种事情发生的.

当用户修改文本, 并且需要跟踪被删除/复制的文本, 又或者是跟踪通常情况下对文本作
出的修改时, 可以使用 Vim 提供的两个工具:
\begin{itemize}
    \item 寄存器: 寄存器是一种带有多个缓冲区的高级剪贴板, 可以用来存放被剪切,
        删除或复制的文本.
\marginpar{99}
    \item 撤消分支: 撤消分支是 Vim 版本控制的一种简单形式. 利用撤消分支, 用户
        可以把文件回滚到某个特定的时刻, 或者是回滚一定的次数. 如果用户对某些
        撤消操作感到后悔, 还可以回过头来找到包含这些修改的撤消分支.
\end{itemize}

接下来的两节将会向读者介绍如何在日常的工作中运用寄存器与撤消分支. 读完
之后, 读者将会认识到它们的强大之外, 以及它们在日常工作是如何帮助用户的.

\subsection{寄存器}
\label{subsec:using_registers}

在许多程序与操作系统中, 用户只能利用一个剪贴板来完成文本的剪切与复制. 在 Vim 中
不会出现这种情况, 因为用户可以访问多达 9 种不同的剪贴板, 更准确来说, 应该是 9
种不的寄存器类型.

有些寄存器类型的工作领域有所重叠, 但还有一些则拥有自己独特的目的. 用户可以在多
种不同的命令或操作中 (比如复制, 删除, 粘贴) 使用寄存器. 寄存器的名字都以双引号
\texttt{"} 开始, 比如 \texttt{"x}, 所以, 现在来看一下如何使用一个寄存器.
假设现在要用的寄存器是 \texttt{"x}, 至于 \texttt{x} 实际上是表示哪个寄存器,
稍后解释.

为了把某段文本复制到寄存器中, 可以用命令 \texttt{y} 来完成, 不过这次有所不同,
在复制之前, 先告诉 Vim 被复制文本的存放位置:
\begin{vimcmdform}
\texttt{"xy} (用 \texttt{"xyy} 可以复制一整行)
\end{vimcmdform}
对于用来剪切文本的命令 \texttt{x} 也是一样的:
\begin{vimcode}
"xx
\end{vimcode}
对于删除文本的命令 \texttt{d} 则是:
\begin{vimcode}
"xd
\end{vimcode}

现在, 用户已经在寄存器 \texttt{"x} 中存放了一段文本, 并且想要把这段文本粘贴到
正式文本中, 可以用命令 \texttt{P} (粘贴在光标位置之前) 或 \texttt{p} (粘贴在
光标位置之后), 但在粘贴之前, 要先指定寄存器:
\begin{vimcmdform}
\texttt{"xP} 或 \texttt{"xp}
\end{vimcmdform}
\marginpar{100}

如果用户忘记自己使用了哪些寄存器, 可以执行命令:
\begin{vimcode}
:registers
\end{vimcode}

现在, 用户已经知道了如何在基本命令中使用寄存器, 那么接下来将会分别介绍每
一种寄存器类型.

\subsubsection{匿名寄存器}
\label{subsubsec:the_unnamed_register}

之所以称为匿名寄存器, 是因为它只能通过 \texttt{""} 来访问. 每当用户使用命令
\texttt{y} 复制文本, 或者是用 \texttt{d} (删除), \texttt{c} (删除, 并进入插入
模式), \texttt{s} (替换), \texttt{x} (剪切) 删除文本时, Vim 都会自动填充该寄存
器. 匿名寄存器始终指向最近使用的寄存器, 也就是说, 即使用户在删除/复制文本时,
指定了一个特定的寄存器, 匿名寄存器也可以正常工作. 比如说, 命令 \texttt{"xdd}
会把被删除的文本同时存入寄存器 \texttt{x} 与匿名寄存器.

如果用命令 \texttt{p} 或 \texttt{P} 粘贴文本时没有指定寄存器, 那么 Vim 就从匿名
寄存器获取被粘贴的文本.

\subsubsection{行内删除寄存器}
\label{subsubsec:the_small_delete_register}

如果用户删除的文本小于一行, 那么 Vim 就把删除的文本存入一个特殊的寄存器 --- 行
内删除寄存器 \texttt{"-}, 前提是用户没有指定其他的寄存器.

\subsubsection{带编号的寄存器}
\label{subsubsec:the_numberred_registers}

带编号的寄存器包括 \texttt{"0}, \texttt{"1}, 一直到 \texttt{"9}. 带编号的寄存
器分为两类, 第一类是寄存器 \texttt{"0}, 它总是包含了最近一次被删除 (\texttt{d}
或 \texttt{x})/修改 (\texttt{c}) 的文本. 如果用户删除或修改了新的文本, 寄存器
\texttt{"0} 的内容就会被新文本覆盖.

类似于寄存器 \texttt{"0}, 寄存器 \texttt{"1} 也包含了最近一次被删除/修改的文本.
然而, 如果用户指定了其他的寄存器, 又或者是文本的长度少于一行 (此时会自动使用
行内删除寄存器), 那么寄存器 \texttt{"1} 的内容就不会被覆盖. 为了和 vi 兼容, 如
果在删除/修改文本时, 使用下面这些移动命令: \verb'%', \verb'(', \verb')',
\verb'{', \verb'}', \verb'`', \verb'/', \verb'?', \verb'n', \verb'N', 那就总是
使用寄存器 \texttt{"1}, 如果文本少于一行, 还会把文本存入寄存器 \texttt{"-}.
\marginpar{101}

和寄存器 \texttt{"0} 有所不同的是, 寄存器 \texttt{"1} 的内容并不会因为新内容的
加入而被删除, 相反, 原有的内容会移到寄存器 \texttt{"2}. 如果寄存器 \texttt{"2}
原来是非空的, 那么寄存器 \texttt{"2} 的内容会先移到寄存器 \texttt{"3}, 以此类推,
直到寄存器 \texttt{"9}. 寄存器 \texttt{"9} 的原有内容会由于新内容的加入而被覆
盖掉. 通过这种方式, 寄存器 \texttt{"1} 到寄存器 \texttt{"9} 就可以记住删除/修
改的历史内容, 即使用户删除了新的文本, 也可以通过这 9 个寄存器访问到早先被删除
的文本.

\subsubsection{命名寄存器}
\label{subsubsec:the_named_registers}

命名寄存器分为两种 --- \texttt{"a} 到 \texttt{"z} 与 \texttt{"A} 到
\texttt{"Z}.

如果使用的是小写字母的寄存器, 比如 \texttt{"a}, 那么它们就像普通的寄存器那样
工作 --- 将删除或复制的文本存入该寄存器. 当有新的内容被添加进来时, 寄存器中原
来的内容就会被覆盖掉.

如果使用的是大写字母的寄存器, 比如 \texttt{"A}, 那么当有新的内容被添加进来时,
原来的内容并不会被覆盖掉, 而是把新内容追加到原有内容的末尾.

\begin{warning}
    如果往选项 \texttt{coptions} 添加新值 \texttt{'>'}, 那么追加到大写字母寄
    存器的新文本与旧文本之间将会以换行符分开, 给选项设置新值的命令是:
    \texttt{:set coptions+='>'}.
\end{warning}

因为用户对命名寄存器具有完全的控制力, 因此用户应该最先熟悉如何使用它们.

\subsubsection{只读寄存器}
\label{subsubsec:the_read_only_registers}

有四个只读寄存器, 它们的特殊之外在于只有 Vim 才有权限修改它们. 用户只能
通过命令 \texttt{P}, \texttt{p} 或 \texttt{:put} 访问它们的内容. 四个只读寄
存器存放的内容有所不同:
\begin{itemize}
    \item \texttt{"\%}: 该寄存器包含了当前活动缓冲区的文件名.
    \item \texttt{"\#}: 该寄存器包含了当前活动缓冲区上一次打开的文件, 也被称为
        备选文件.
    \item \texttt{".}: 该寄存器总是包含了最近一次插入的文本. 因此, 用户可以通
        过执行 \texttt{".p} 来重复粘贴最近一次插入的文本.
\marginpar{102}
    \item \texttt{":}: 该寄存器包含了用户上一次在命令行执行的命令. 如果用户重
    复执行一条历史命令, 那么寄存器的内容就不会被覆盖. 为了使被执行的命令存入
        该寄存器, 用户至少需要输入命令中的一个字符.
\end{itemize}

\subsubsection{选择与投递寄存器}
\label{subsubsec:the_selection_and_drop_registers}

这种寄存器类型包含了三个寄存器: \texttt{"*}, \texttt{"+} 与 \verb'"~'. 这 3
个寄存器用于存放与检索用户在 Gvim 中选择的文本. 寄存器 \texttt{"*} 实际上访问
的是窗口系统的剪贴板. 如果使用的操作系统是 Miscrosoft Windows, 那么用户在使用
寄存器 \texttt{"*} 与 寄存器 \texttt{"+} 并不会感到有什么不同. 然而, 如果是
Linux, 那就不一样了, 因为 X11 (Linux 的窗口系统) 的选择寄存器不止一个, 而是三
个. 寄存器 \texttt{"+} 存放的是用户所选择的任意一段文本, 典型的选择方式是通过
鼠标完成. 然而, 仅当用户显式地告诉 Vim 去复制文本时, 寄存器 \texttt{"*} 的内
容才会改变.

任意一个 GUI 应用程序都可以访问这些寄存器, 它们的使用方法和日常的复制粘贴没
什么区别.

最后一个寄存器 \verb'"~' 称为投递寄存器, 它包含了最近一次投递到 Vim 的文本.
所以说, 如果用户在另一个程序中选择了一段文本, 并把它拖动到 Vim 的窗口中, 那么
寄存器 \verb'"~' 就包含了这段文本.

\subsubsection{黑洞寄存器}
\label{subsubsec:the_black_hole_register}

顾名思义, 这个寄存器就像黑洞那样工作 --- 进入该寄存器的任意内容都无法再被取
回. 如果用户希望彻底删除某些文本, 也不想让任意一个寄存器记录被删除的文本, 此
时就可以用黑洞寄存器. 黑洞寄存器的名字是 \texttt{"\_}, 使用寄存器的例子有
\texttt{"\_x} 或 \texttt{"\_dd}. 如果用户试图读取刚刚写入到该寄存器的内容, 将
会发现, 无论如何尝试, 都不会返回任何内容.

\subsubsection{搜索模式寄存器}
\label{subsubsec:search_pattern_register}

无论何时使用命令 \texttt{/}, 被搜索的模式都会自动存入搜索模式寄存器. 寄存器
的名字 \texttt{"/} 非常容易记忆, 因为它就是在搜索命令 \texttt{/} 前加上了双
引号, 表明这是一个寄存器. 如果打开了选项 \texttt{hlsearch}, Vim 就会根据寄存
器中的内容来高亮文本. 用户可以利用这个特点, 修改寄存器的内容, 从而高亮显示
其他文本. 在不执行搜索的前提下修改寄存器内容的方法是:
\marginpar{103}
\begin{vimcmdform}
    \texttt{:let @/="}\textit{pattern}\texttt{"}
\end{vimcmdform}
命令中的 \textit{pattern} 是 \texttt{hlsearch} 将要高亮显示的字符串.

\subsubsection{表达式寄存器}
\label{subsubsec:the_expression_register}

Vim 的最后一种寄存器类型是表达式寄存器, 然而, 称它为寄存器并不恰当, 因为它并不
像其他通常的寄存器那样存放文本, 用户甚至不能写该寄存器. 取而代之的是, 它允许用
户访问命令行, 对表达式求值并返回运算结果, 就好像它一开始就存放在寄存器中似的.

访问表达式寄存器的方式是输入它的名字 \texttt{"=}. 输入完等号后, 光标自动跳转
到命令行窗口, 如果命令行窗口的第一个字符是等号, 则说明用户现在工作在表达式寄
存器. 现在用户可以输入待求值的表达式, 并以回车键结束, 之后, 可以用命令
\texttt{p} 或 \texttt{:put} 把运算结果粘贴到正文中. 如果不想对已输入的表达式
进行求值, 则按 \key{Esc} 结束. 如果用户在按回车键之前没有输入表达式, Vim 就会
使用上一次输入的表达式. 表达式必须是有效的, 而且应该返回一个字符串. 如果表达式
的结果是数值, Vim 会自动把它转换成字符串. 如果用户无法确定运算结果的类型, 可以
使用函数 \texttt{string()} 把结果转换成字符中再返回.\footnote{对表达式寄存器更
方便的用法是: 在插入模式下, 按 \texttt{<c-r>=} (按组合键 \textit{Ctrl+R}, 再
按等号), 接着输入待求值的表达式, 输入完按回车键, 运算结果就会自动插入到正文中.
--- 译者注}

\begin{warning}
    执行 \texttt{:help expression}, 查看如何输入有效的表达式.
\end{warning}

\subsection{撤消分支}
\label{subsec:using_undo_branching}

用户应该都执行过对已修改文本的撤消操作. 通常情况下, 执行撤消操作的方式是按工具
栏的撤消按钮, 或者是组合键, 这样, 最后一次对文本的修改就会被撤消.

在这一方面, Vim 走得更远一些, 而且新增了对分支的支持.

这一节介绍什么是撤消分支, 以及如何在日常工作中使用它.
\marginpar{104}

先来介绍一下什么是撤消分支. 假设现在有一个文件, 而用户已经在它上面作了很多
修改, 这时, 用户突然意识到最后四次更改是错误的. 通常来说, 这时用户会执行四次
撤消命令 (或者直接执行 \texttt{4u}), 这样的话, 最后四次更改就会被取消. 在这里
执行的撤消操作和其他编辑器中的撤消操作没什么不同. 假设现在用户想要对文件作另
一个更改, 比如说改正一个拼写错误.

如果用户此时修改了拼写错误, 那么, 一般来说, 之前被撤消的四次更改操作, 其信息
都会被丢掉 --- 不过 Vim 并不会这样做.

当用户撤消了四次修改, 并添加了一个新修改时, Vim 会在撤消分支树上添加一条新分
支, 此时的撤消分支树看起来就像:
\begin{vimcode}
        A-B-C-D
        /
    E-F-G-H
\end{vimcode}

其中一条分支包含了四个已经被撤消的修改, 另一条分支则包含了最近几次的修改 (拼
写改正). 如果用户继续编辑文本 (不包含撤消操作), 那么撤消树中就只会有这两条分
支. 如果用户在撤消某些操作后, 又作了新的修改, 撤消树就会新增一条分支. 到了最
后, 用户将会看到一棵长满分支的撤消树, 它包含了所有的撤消与编辑操作.

下面这个命令可以查看当前存在着的撤消分支的概览:
\begin{vimcode}
:undolist
\end{vimcode}
命令会显示分支的三种信息 --- 修改号 (用于标识一条分支), 分支所包含的修改的次
数, 分支上最后一次修改发生的时间, 命令的输出信息就像:
\begin{vimcode}
number  changes time ~
6       5       12:12:11
11      8       14:01:15
\end{vimcode}

如果用户想要切换到某个特定的修改号, 执行:
\begin{vimcmdform}
\texttt{:undo }\textit{n}
\end{vimcmdform}
命令中的 \textit{n} 是修改号.
\marginpar{105}

可以用下面的命令在修改列表中后退:
\begin{vimcmdform}
    \texttt{g-}(如果是前进的话, 则是 \texttt{g+})
\end{vimcmdform}

那么, \texttt{g-} 与 \texttt{u} 之间有什么区别? 让我们通过例子来说明.

在 Vim 的编辑区中输入下面的文本:
\begin{vimcode}
My name is Jim
\end{vimcode}
把光标移动到跳到字母 \texttt{J}, 按三次 \texttt{x} 来删除名字 \texttt{Jim},
文本变成了:
\begin{vimcode}
My name is Jim
My name is im
My name is m
My name is 
\end{vimcode}
现在, 用户突然意识到正确的名字是 \texttt{Jimmy}, 于是他撤消了修改:
\begin{vimcode}
My name is m
My name is im
My name is Jim
\end{vimcode}
撤消之后, Vim 中已经有了一条删除名字 \texttt{Jim} 的撤消分支. 现在把名字改为
\texttt{Jimmy}:
\begin{vimcode}
My name is Jimm
My name is Jimmy
\end{vimcode}
但是, 用户真正的名字其实是 \texttt{Kim}, 而非 \texttt{Jimmy}. 因为 \texttt{Jim}
已经和 \texttt{Kim} 很接近了, 所以用命令 \texttt{u} 回滚, 并把 \texttt{J} 改成
\texttt{K}:
\begin{vimcode}
My name is Jimm
My name is Jim
My name is im
My name is Kim
\end{vimcode}
把 \texttt{Jim} 回滚到 \texttt{Jimmy} 后, 会新增一条撤消分支.

现在, 用命令 \texttt{g-} 在修改列表中后退:
\begin{vimcode}
My name is Kim
My name is im
\end{vimcode}
\marginpar{106}
(从这里开始, Vim 切换到一条新的分支)
\begin{vimcode}
My name is Jim
My name is Jimm
My name is Jimmy
\end{vimcode}
(从这里开始, Vim 切换到一条新的分支)
\begin{vimcode}
My name is 
My name is m
My name is im
My name is Jim
\end{vimcode}
如果用的是命令 \texttt{u}, 则变化过程是:
\begin{vimcode}
My name is Kim
My name is im
My name is Jim
My name is Jimm
My name is Jimmy
My name is Jim
\end{vimcode}
可以看到, 命令 \texttt{u} 只是单纯地撤消施加上文本上的修改, 并不理会分支的变化.
而命令 \texttt{g-} 则会按照分支来进行撤消.

简单来说, 撤消分支使得用户可以访问到文本曾经经历过的任何状态.

除了在分支中一步一步地回退之外, 还可以直接跳转到某个时间点的文本状态. 为了完
成这个功能,
Vim 提供了两个命令, 分别用来在撤消历史中向前跳转和向后跳转, 命令的执行形式是:
\begin{vimcmdform}
\texttt{:earlier }\textit{N}\texttt{s} \\
\texttt{:earlier }\textit{N}\texttt{m} \\
\texttt{:earlier }\textit{N}\texttt{h} \\
\texttt{:later }\textit{N}\texttt{s} \\
\texttt{:later }\textit{N}\texttt{m} \\
\texttt{:later }\textit{N}\texttt{h}
\end{vimcmdform}
命令中的 \textit{N} 表示跳过的秒数(\texttt{s}), 分种数 (\texttt{m}), 或小时数
(\texttt{h}). 命令 \texttt{:undolist} 可以显示分支上最后一次修改发生的时间, 通
过这个信息, 用户可以大致计算出需要跳过的时间长度.
\marginpar{107}
熟悉撤消分支的使用可能会需要点时间, 可是一旦上手之后, 它会对用户的日常工作产生
极大的帮助.

\section{折叠}
\label{sec:folding}

一般来说, 编辑大型文件时 (尤其是源代码文件), 用户很难获取一份好的概览. Vim 提
供了一个特性可以解决这个问题 --- 折叠文本块. 这一节介绍如
利用折叠获取文本内容的概览.

折叠指的是将一个范围内的行 (比如一个函数的定义) 折叠成一行, 但不丢失文本内容.
比如折叠下面的文本:
\begin{vimcode}
function myFunction() {
    var a = 1;
    var b = 0;
    var c = a + b;
    return c;
}
\end{vimcode}
折叠后的效果类似于:
\begin{vimcode}
+-- 6 lines: function myFunction() {
\end{vimcode}
在这个示例中, 折叠是根据代码的语法, 用花括号来判断被折叠的范围. Vim 可以根据
下面的信息来折叠文本:
\begin{itemize}
    \item 手动折叠: 由用户手动标出被折叠的范围 (见 \texttt{:help fold-manual})
    \item 缩进折叠: 根据缩进来折叠文本 (见 \texttt{:help fold-indent})
    \item 表达式折叠: 根据表达式来折叠文本 (见 \texttt{:help fold-expr})
    \item 语法折叠: 根据语法来折叠文本 (见 \texttt{:help fold-syntax})
    \item 差异折叠: 折叠未被修改的文本 (见 \texttt{:help fold-diff})
    \item 标记折叠: 根据文本中插入的标记来折叠文本 (见
        \texttt{:help fold-marker})
\end{itemize}
具体使用哪一种指示信息取决于文本的类型, 以及用户的具体操作.
\marginpar{108}

现在开始介绍如何完成折叠操作, 在这之前, 要做的第一件事是打开折叠选项:
\begin{vimcode}
:set foldenable
\end{vimcode}
打开后, Vim 就会注意到在普通模式下输入的折叠命令. 用来打开和关闭折叠的命令有很
多个, 主要的有:
\begin{itemize}
    \item \texttt{zc}: 关闭一个折叠
    \item \texttt{zo}: 打开一个折叠
    \item \texttt{zM}: 关闭所有的折叠
    \item \texttt{zR}: 打开所有的折叠
\end{itemize}
假设把语法折叠作为折叠时的指示信息, 首先把光标移动到需要折叠的区域 (比如某
个函数的内部), 切换到普通模式, 执行命令 \texttt{zc} 来关闭折叠, 现在, 用户就可
以看到函数的定义代码被折叠成一行. 下面的图片显示了折叠与未折叠的代码:
\begin{center}
\includegraphics[scale=0.55]{./images/page108.png}
\end{center}

\begin{warning}
    如果用户不想记住打开与关闭折叠的命令, 可以把打开或关闭折叠的切换命令绑定
    到一个按键上, 比如空格: \texttt{:nnoremap <space> za}
\end{warning}

如果用户觉得折叠后的行无法提供自己想要的信息, 可以通过修改选项
\texttt{foldtext} 的值来改变折叠行所显示的信息. 修改的方式是让
\texttt{foldtext} 指向另一个函数, 这个函数返回用户希望看到的信息:
\begin{vimcode}
:set foldtext=MyFoldFunction()
\end{vimcode}
函数 \texttt{MyFoldFunction()} 的实现代码是:
\marginpar{109}
\begin{vimcode}
function! MyFoldFunction()
	let line = getline(v:foldstart)
	" cleanup unwanted things in first line
	let sub = substitute(line, '/\*\|\*/\|^\s+', '', 'g')
	" calculate lines in folded text
	let lines = v:foldend - v:foldstart + 1
	return  v:folddashes.sub.'...'.lines.' Lines...'.getline(v:foldend)
endfunction
\end{vimcode}
函数使得折叠后的行变成:
\begin{vimcode}
+--function myFunction() {...6 Lines...}
\end{vimcode}

用户可以看到函数中使用了三个以 \texttt{v:} 开始的变量, 这些变量由 Vim 设置,
分别包含了:
\begin{itemize}
    \item \texttt{v:foldstart}: 被折叠的第一行的行号
    \item \texttt{v:foldend:}: 被折叠的最后一行的行号
    \item \texttt{v:folddashes}: 为每一层折叠包含一个连字符
\end{itemize}

最后一个变量指出了折叠所在的层次. 假设有这样一段代码:
\begin{vimcode}
if (x != y) {
    if (y != x) {
        print "x not y"
    }
}
\end{vimcode}
最内层 \texttt{if} 的 \texttt{v:folddashes} 将会包含 \texttt{--} (第二层), 而
最外层 \texttt{if} 的 \texttt{v:folddashes} 则是 \texttt{-} (第一层).

折叠行末尾的连字符是自动加上去的. 如果用户希望使用其他字符, 比如等号, 可以这
样做:
\begin{vimcode}
:set fillchars=fold:=
\end{vimcode}

用户可能会感到奇怪为什么需要连字符? 当中的原因其实非常明显. Vim 还有一个称为
\texttt{foldcolumn} 的折叠设置选项, 这个选项说明了应该使用文本左边的多少列
来显示折叠信息. 选项实际上是用这些列画出一个 ASCII 折叠树, 折叠中的连字符就
是树叶. 例如:
\begin{vimcode}
| some text
+- a first level fold
|
    beginning of open fold
2   indication of fold level
2     - do -
- open fold beginning level 1
+-- a second level fold.
| more text
| more text
\end{vimcode}
\marginpar{110}

正如用户所看到的那样, Vim 用 ASCII 字符画出了一棵树:
\begin{vimcode}
|
+-
|
+--
|
+-
+--
\end{vimcode}
下面的命令可以设置树的宽度:
\begin{vimcmdform}
\texttt{:set foldcolumn=}\textit{n}
\end{vimcmdform}
命令中的 \textit{n} 是一个 0 到 12 之间的数, 如果折叠的层次比较少, 推荐使用 1
或者 2; 否则的话, 推荐使用 3 到 5.

\begin{warning}
    用户可以对打开或关闭着的所有折叠执行某个命令:
    \begin{itemize}
        \item \texttt{:folddoopen }\textit{cmd}: 对所有未在关闭的折叠中的行
            执行命令 \textit{cmd}
        \item \texttt{:folddoclose }\textit{cmd}: 对所有处在关闭的折叠中的行
            执行命令 \textit{cmd}
    \end{itemize}
\end{warning}

\subsection{提取大纲}
\label{subsec:simple_text_file_outlining}

当用户使用 Vim 编写一个简单的文本文件时, 可能会突然意识到文件已经写得又长又乱
了, 这时候就很需要为文件列一个提纲. 这一节介绍如何使用折叠来为文
件提取大纲, 提取大纲对于改善文件的结构至关重要.

假设文本文件的内容是:
\begin{vimcode}
Chapter 1
Section 1 - Vim help
here is some text about the vim help system.
Section 2 - vim scripts
this section contains info about vim scripts.
\end{vimcode}
\marginpar{111}

现在, 用户想要折叠文本, 使得只有 Section 的头部显示出来. 如果用手动折叠 (
\texttt{:set foldmethod=manual} 则比较方便, 方法是选中 Section 内的所有行 (包
括头部), 然后按下 \texttt{zf}, 就可以把这些行折叠起来. 另外, 用户可以认为
\texttt{Chapter 1} 是第一层折叠, 每一个 Section 是第二层, 关闭 Section 所在的
折叠后应该变成:
\begin{vimcode}
-Chapter 1
+Section 1 - Vim help   (2)
+Section 2 - Vim scripts    (4)
\end{vimcode}

\begin{warning}
    为了达到上面的效果, 需要做如下设置:
    \begin{vimcode}
    :set foldcolumn=1
    :set fillchars=fold:\  "there is a space after the \
    :set foldtext=getline(v:foldstart).'    ('.v:foldstart.')'
    \end{vimcode}
\end{warning}

经过这样的处理之后, 文件看起来就像是书籍的目录, 不同之处是这仅仅是一个普通的文本
文件而已. 只要新增的行是在之前的行的后面, Vim 就仍然会把新增的行当作是折叠的一
部分.

如果想要删除折叠, 只需要在可视模式下选中文本, 再按下 \texttt{zd}.

如果用户想让文本拥有不同的格式 (比如, 用 \texttt{= =} 包围 Section 的头部),
这当然可以实现 --- 只要用户标记了自己的折叠区域, 那么实现起来就不会有什么问题.

\subsection{使用 vimdiff 比较差异}
\label{subsec:using_vimdiff_to_track_the_changes}

有时候, 用户可能拥有同一文件的多个版本 --- 这些版本之间可能相同, 也可能不同.
在 Unix 系统中, 有一个称为 \texttt{diff} 的命令, 这个命令很早就开始被人们使用
(最早出现于 1974 年), 但是其他系统很可能没有该命令. 这个命令的功能是显示两个
文件的差异, Vim 也提供了一个用于比较差异的工具 --- \texttt{vimdiff}. 这一节介
绍如何使用 Vim 比较文件的差异.
\marginpar{112}

\texttt{vimdiff} 是 Vim 内置的差异比较工具, 它使用颜色显示文件间的差异 (被
比较的两个文件分别处在两个纵向切割或横向切割的窗口中). 下面的图片显示了
\texttt{vimdiff} 的工作界面:
\begin{center}
    \includegraphics[scale=0.5]{./images/page112.png}
\end{center}

有若干种方式可以用来启动 \texttt{vimdiff}. 在安装了 Vim 的系统中, 一般都有一
个叫作 \texttt{vimdiff} 的程序快捷键, 用户可以通过它启动 \texttt{vimdiff}:
\begin{vimcode}
vimdiff file1 file2
\end{vimcode}
上面的命令行等价于:
\begin{vimcode}
vim -d file1 file2
\end{vimcode}

启动 \texttt{vimdiff} 时至少需要提供两个文件进行比较, 至多可同时比较 4 个文件.

如果用户已经启动了 Vim, 并且想要激活 \texttt{diff} 模式, 那么可以这样做:
\begin{itemize}
    \item \texttt{:diffsplit }\textit{filename}: 水平切割窗口, 并在其中一个窗口
        打开 \textit{filename}, 所有和 \texttt{vimdiff} 相关的设置会同时应用
        到这两个窗口中.
    \item \texttt{:vert diffsplit }\textit{filename}: 垂直切割窗口, 并在其中
        一个窗口中显示 \textit{filename}, 所有和 \texttt{vimdiff} 相关的设置
        会同时应用到这两个窗口中.
    \item \texttt{:diffthis}: 使得当前窗口成为差异窗口的一部分. 当用户想要再
        次对某个文件进行差异比较时, 可能会用到该命令.
\end{itemize}
\marginpar{113}

一个常见的例子是比较当前文件, 与上一次 Vim 所保存的备份之间的差异 (备份文件的
文件名以波浪号 \verb'~' 结尾). 假设用户正在编辑的文件是 \texttt{main.c}, 则
可以在任意时刻保存文件, 然后执行:
\begin{vimcode}
:vert diffsplit main.c~
\end{vimcode}
执行命令后, 窗口被垂直分割成两个, 文件间的差异通过颜色标记出来 (具体的颜色
取决于当前使用着的色彩主题)

还有一种情况是, 对文件作出修改的并不是用户本人,  而是另一个开发人员向用户发
了一个文件补丁, 对于这种情形, Vim 也提供了一个 \texttt{diff} 视图, 用于查看补
丁被应用到文件后所带来的变化. 方法是打开补丁所对应的文件, 然后执行 \texttt{vert
diffpatch }\textit{patchfile}, 或者省略 \texttt{vert}, 直接执行
\texttt{:diffpatch }\textit{patchfile}.

命令中的 \textit{patchfile} 是其他开发人员发送给用户的补丁. 执行命令后,
Vim 会在另一个窗口中打开文件, 把补丁打到该文件上, 然后比较打补丁前, 与打补
丁后文件的差异.

\subsection{在 vimdiff 中导航}
\label{subsec:navigation_in_vimdiff}

和普通的 Vim 窗口相比, 在 \texttt{vimdiff} 窗口中导航会稍有不同.

例如, 滚动其中一个窗口时, 会同时滚动另一个窗口. 实际上, 窗口之间的每一行, 其
相对位置不变, 这是通过选项 \texttt{scrollbind} 来实现的:
\begin{itemize}
    \item 开启同时滚动的命令是:
\begin{vimcode}
:set scrollbind
\end{vimcode}
    \item 关闭同时滚动的命令是:
\begin{vimcode}
:set noscrollbind
\end{vimcode}
\end{itemize}

当在 \texttt{diff} 窗口中编辑文件时, Vim 会自动根据文件内容的变化, 来相应地更
新窗口中的颜色; 如果没有更新, 则可以执行:
\begin{vimcode}
:diffupdate
\end{vimcode}
\marginpar{114}

如果光标正处在某一 \texttt{diff} 窗口中, 而用户希望在修改之间快速地跳转, 这就
需要用到下面的命令:
\begin{itemize}
    \item \texttt{[c}: 跳转到前一个修改的开始
    \item \texttt{]c}: 跳转到下一个修改的开始
\end{itemize}
通过这种方法, 用户可以在文件的相关区域间方便地跳转, 并且可以很容易看出对文件
作了哪些修改.

如果光标正处在 \texttt{vimdiff} 窗口的某一差异上, 而且用户知道该修改对文件的
另一版本也是需要的. 虽然可以把修改复制下来, 并插入到另一个文件的适当位置, 但
是 Vim 提供了比这更方便的做法. 下面这个命令可以把修改应用到同一文件的另一个版
本上:
\begin{vimcode}
:diffput
\end{vimcode}

执行该命令时, 光标必须处在待应用的修改上. 另一方面, 如果光标是处在不含有修改
的文件上, 那么用户可以先跳转到含有修改的文件上, 然后把修改应用到另一个文件,
或者直接使用下面的命令:
\begin{vimcode}
:diffget
\end{vimcode}
除了这两个命令, 还可以在普通模式下使用另外两个替代命令 \texttt{do} 与
\texttt{dp}.

\begin{warning}
    更多的内容请参考 \texttt{:help vimdiff}.
\end{warning}

\subsection{使用 diff 跟踪变化}
\label{subsec:using_diff_to_track_changes}

前面一节已经学习到如何使用 \texttt{vimdiff} 来比较同一文件的不同版本之
间的差异, 但是, 如果用户仅仅是想知道在保存之前, 对当前活动缓冲区作了哪些修
改, 那又应该怎么办呢? 这一节介绍如何查看硬盘上的文件与缓冲区中的文件之间的差
异, 也就是自从上一次保存以来, 文件所发生的变化.
\marginpar{115}
用户所要做的首先是把下面的代码添加到文件 \texttt{vimrc}:
\begin{vimcode}
function! DiffWithFileFromDisk()
	  let filename=expand('%')
	  let diffname = filename.'.fileFromBuffer'
	  exec 'saveas! '.diffname
	  diffthis
	  vsplit
	  exec 'edit '.filename
	  diffthis
	endfunction
\end{vimcode}

函数为当前缓冲区中的文件保存一份临时副本 (包含了最新的修改), 然后对临时文件与
硬盘上的文件进行差异比较.

为了调用这个函数, 需要执行:
\begin{vimcode}
:call DiffWithFileFromDisk()
\end{vimcode}
也可以为调用命令绑定一个快捷键:
\begin{vimcode}
:nmap <F7> :call DiffWithFileFromDisk()<cr>
\end{vimcode}
上面的命令把功能键 \key{F7} 绑定到函数调用, 使用时只需要切换到普通模式, 再按
下 \key{F7}, 就可以看到用 \texttt{diff} 模式标记的修改.

现在, 用户就可以在保存文件之前, 查看所有未保存的修改, 检查是否每个修改都是正确
的.

\section{打开任意位置的文件}
\label{sec:open_files_anywhere}

系统管理员与网站开发人员经常会被同一个问题所困扰, 如果解决得不好的话, 会给人带
来很大的麻烦, 这个问题就是他们所浏览的文件大部分都存放在远程服务器上.

系统管理员对此问题的解决办法通常是远程登录到服务器上 (比如用 ssh (Secure
Shell), 然后再在服务器上直接修改配置文件.

网站开发人员的解决办法通常是先把文件下载到本地, 编辑好后再上传到服务器上, 下
载与上传的工具可以用 FTP 客户端, 或 Webdav.
\marginpar{116}

如果不使用上面提到的方法, 那又应该怎么办呢? 为什么他们就不能在本地直接编辑远程
服务器上的文件? Vim 可以在不需要额外扩展的前提下完成这件事. Vim 含有一个称为
netrw (Net Read/Write) 的系统, 它可以用来编辑远程服务器上的文件,
通过例子介绍如何使用它.

假设有一个网站开发人员, 叫作 John, 他把他的主页放在远程服务器
\texttt{remote.server.com} 上. 现在他想要编辑文件 \texttt{index.html}, 这个文
件存放在服务器家目录下的 \verb'public_html/'. 使用 Vim 打开此文件的命令是:
\begin{vimcode}
vim ftp://john@remote.server.com/public_html/index.html
\end{vimcode}

Vim 根据参数识别出它需要使用 FTP 协议连接到服务器 \texttt{remote.server.com},
所使用的用户名是 \texttt{john}, 如果还需要输入密码, Vim 就会在连接时给出
提示信息. Vim 从服务器上下载一份文件的副本到本地, 用户所编辑的正是该副本, 所
不同的是每当用户保存文件时, Vim 都会同时保存一份到服务器上.

如果 John 已经打开了 Vim, 则可以使用下面两个命令中的一个打开远程服务器上的文
件:
\begin{vimcode}
:Nread ftp://john@remote.server.com/public_html/index.html
:Nread remote.server.com john PASSWORD public_html/index.html
\end{vimcode}
命令中的 \texttt{PASSWORD} 是登录时所使用的密码. 除了可以读取远程服务器上的文
件, 还可以把本地文件写到远程服务器上, 甚至可以在一台服务器上打开文件, 并把它
保存到另一个服务器上. 把文件保存到 FTP 服务器的命令是:
\begin{vimcode}
:Nwrite ftp://user@server/path/to/filename
:Nwrite server user password path/to/filename
\end{vimcode}

\begin{warning}
    针对不同的协议, \texttt{:Nread} 与 \texttt{:Nwrite} 所使用的参数也有所不
    同, 可以通过 \texttt{:Nread ?} 与 \texttt{:Nwrite ?} 查看具体的规则.
\end{warning}

除了 FTP, Vim 还支持以下协议:
\begin{itemize}
    \item SCP
    \item SFTP
    \item RCP
    \item HTTP (只读)
    \item DAV
\marginpar{117}
    \item rsync (只读)
    \item fetch (只读)
\end{itemize}

为了在 Vim 的命令中使用这些协议, 只需要把前面例子中的 \texttt{ftp} 替换成对应
的协议名 (小写形式) 即可.

然而, 有一点需要注意. 为了使用这些协议, Vim 依赖于外部的命令行程序. 在 Linux
系统中, 这些程序默认都是可用的, 但是对于 Miscrosoft Windows 来说, 只有 FTP
是可用的. 为了查看 Vim 所使用的外部程序, 以及如何修改它们, 执行:
\begin{vimcode}
:help netrw-externapp
\end{vimcode}

除了读取与编辑远程文件, Vim 还可以列出远程目录中的所有文件, 这做便于用户选择
正确的文件进行编辑. 为了列出远程目录中的文件, 只需要把 \texttt{:Nread} 的参数
由文件改为目录即可, 例如:
\begin{vimcode}
:Nread scp://user@server/some/directory/
\end{vimcode}
执行命令后, 用户可以选择任意一个文件进行编辑, 就好像它们就在本地目录.

\begin{warning}
    如果是 Linux 系统, 则用户可以把登录远程服务器所用的用户名与密码保存到本地
    家目录的 \texttt{.netrc} 文件中, 更多的信息参考 \texttt{:help netrw-netrc}.
\end{warning}

\subsection{更快的远程文件编辑}
\label{subsec:faster_remote_file_editing}

用户既然已经知道了如何直接编辑远程服务器上的文件, 那么他就很有可能同时打开多个
远程文件. 这时用户就会遇到一个很恼人的情况: 每当移动到另一个缓冲区时 (用命令
\texttt{:bufferprev} 或 \texttt{:buffernext}), 都需要重新登录.

默认情况下, 每次显示缓冲区的文件内容时, Vim 都会尝试重新加载文
件. 也就是说, 如果打开的是一个远程文件, 那么 Vim 就会尝试重新登录, 以检查文件是
否需要重新加载.

但是这真的有必要吗? 如果远程文件除了用户之外, 没有其他人正在编辑, 那么在切换
缓冲区时就不需要重新加载文件.
\marginpar{118}

每一个缓冲区都有一套选项, 指明了在不同的情况下如何处理缓冲区. 其中之一就是
\texttt{bufhidden}, 它表示当缓冲区被隐藏 (在窗口中不可见) 时 Vim 该做什么操作.
默认情况下该选项的值为空, 如果把它设置成 \texttt{hide}, 那就是告诉 Vim 当在
窗口中看不到缓冲区时, 只需把它隐藏即可; 当再次把它显示在窗口中时, 只需把它显示
出来即可. 为了不让 Vim 在切换缓冲区时重新从远程加载文件, 在 \texttt{vimrc} 中
添加:
\begin{vimcode}
set bufhidden=hide
\end{vimcode}

\section{小结}
\label{sec:production_boosters_summary}

这一章介绍了如何在日常工作中更高效地使用 Vim. 介绍了很多方法, 也提出
了一些优化措施.

首先是介绍了如何利用模版来降低文本输入的工作量. 最开始是使用缩写来插入模版,
然后, 是根据不同的文件类型来制作并插入对应的模版文本. 最后, 讨论如何使用
snipMate 脚本来为任意的文件格式制作代码片断脚本.

接着是自动补全. 我们介绍了各种不同的补全方法, 还说明了如何把众多补全方法都绑
定到 \key{Tab} 键上.

通过记录一系列命令, 用户就可以多次重复执行同一段命令序列. 说明了如何使用
宏录制, 把日志文件的内容转换成 HTML 格式.

再接下来是 Vim 的会话. 介绍了如何保存窗口的状态, 以及如何把会话用作项目
管理程序.

通过寄存器, 用户可以使用多达 9 个不同的寄存器/剪贴板.

通过折叠文本, 用户能够得到更好的文件概览, 因为无关紧要的部分都被隐藏在了折叠
中. 还可以利用折叠来制作文件的提纲.
\marginpar{119}

文件被修改过了, 但是具体改了哪些地方呢? 我们介绍了如何使用 Vim 内置的
\texttt{diff} 功能. 通过它, 用户可以获取文件修改的概览, 或者是在维持良好的
\texttt{diff} 概览的前提下, 撤消或添加分支.

编辑本地文件是一回事, 编辑远程机器上的文件是另一回事. Vim 可以做到直接编辑
或操作远程文件, 而且和编辑本地文件相比, 用户并不会感到有什么不同.

在下一章, 我们将会学习到如何使用 Vim 的格式化选项来格式化普通文本或代码.
% end of chapter 4
